/*
 * generated by Xtext
 */
package net.sf.orcc.cal.serializer;

import com.google.inject.Inject;
import java.util.Set;
import net.sf.orcc.cal.cal.AnnotationArgument;
import net.sf.orcc.cal.cal.AstAction;
import net.sf.orcc.cal.cal.AstActor;
import net.sf.orcc.cal.cal.AstAnnotation;
import net.sf.orcc.cal.cal.AstEntity;
import net.sf.orcc.cal.cal.AstPort;
import net.sf.orcc.cal.cal.AstProcedure;
import net.sf.orcc.cal.cal.AstState;
import net.sf.orcc.cal.cal.AstTag;
import net.sf.orcc.cal.cal.AstTransition;
import net.sf.orcc.cal.cal.AstTypeBool;
import net.sf.orcc.cal.cal.AstTypeDouble;
import net.sf.orcc.cal.cal.AstTypeFloat;
import net.sf.orcc.cal.cal.AstTypeHalf;
import net.sf.orcc.cal.cal.AstTypeInt;
import net.sf.orcc.cal.cal.AstTypeList;
import net.sf.orcc.cal.cal.AstTypeString;
import net.sf.orcc.cal.cal.AstTypeUint;
import net.sf.orcc.cal.cal.AstUnit;
import net.sf.orcc.cal.cal.CalPackage;
import net.sf.orcc.cal.cal.ExpressionBinary;
import net.sf.orcc.cal.cal.ExpressionBoolean;
import net.sf.orcc.cal.cal.ExpressionCall;
import net.sf.orcc.cal.cal.ExpressionElsif;
import net.sf.orcc.cal.cal.ExpressionFloat;
import net.sf.orcc.cal.cal.ExpressionIf;
import net.sf.orcc.cal.cal.ExpressionIndex;
import net.sf.orcc.cal.cal.ExpressionInteger;
import net.sf.orcc.cal.cal.ExpressionList;
import net.sf.orcc.cal.cal.ExpressionString;
import net.sf.orcc.cal.cal.ExpressionUnary;
import net.sf.orcc.cal.cal.ExpressionVariable;
import net.sf.orcc.cal.cal.ExternalTarget;
import net.sf.orcc.cal.cal.Fsm;
import net.sf.orcc.cal.cal.Function;
import net.sf.orcc.cal.cal.Generator;
import net.sf.orcc.cal.cal.Guard;
import net.sf.orcc.cal.cal.Import;
import net.sf.orcc.cal.cal.Inequality;
import net.sf.orcc.cal.cal.InputPattern;
import net.sf.orcc.cal.cal.LocalFsm;
import net.sf.orcc.cal.cal.OutputPattern;
import net.sf.orcc.cal.cal.Priority;
import net.sf.orcc.cal.cal.RegExp;
import net.sf.orcc.cal.cal.RegExpBinary;
import net.sf.orcc.cal.cal.RegExpTag;
import net.sf.orcc.cal.cal.RegExpUnary;
import net.sf.orcc.cal.cal.ScheduleFsm;
import net.sf.orcc.cal.cal.StatementAssign;
import net.sf.orcc.cal.cal.StatementCall;
import net.sf.orcc.cal.cal.StatementElsif;
import net.sf.orcc.cal.cal.StatementForeach;
import net.sf.orcc.cal.cal.StatementIf;
import net.sf.orcc.cal.cal.StatementWhile;
import net.sf.orcc.cal.cal.Variable;
import net.sf.orcc.cal.cal.VariableReference;
import net.sf.orcc.cal.services.CalGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CalSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CalGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CalPackage.ANNOTATION_ARGUMENT:
				sequence_AnnotationArgument(context, (AnnotationArgument) semanticObject); 
				return; 
			case CalPackage.AST_ACTION:
				if (rule == grammarAccess.getAstActionRule()) {
					sequence_AstAction(context, (AstAction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInitializeRule()) {
					sequence_Initialize(context, (AstAction) semanticObject); 
					return; 
				}
				else break;
			case CalPackage.AST_ACTOR:
				sequence_AstActor(context, (AstActor) semanticObject); 
				return; 
			case CalPackage.AST_ANNOTATION:
				sequence_AstAnnotation(context, (AstAnnotation) semanticObject); 
				return; 
			case CalPackage.AST_ENTITY:
				sequence_AstEntity(context, (AstEntity) semanticObject); 
				return; 
			case CalPackage.AST_PORT:
				sequence_AstPort(context, (AstPort) semanticObject); 
				return; 
			case CalPackage.AST_PROCEDURE:
				sequence_AstProcedure(context, (AstProcedure) semanticObject); 
				return; 
			case CalPackage.AST_STATE:
				sequence_AstState(context, (AstState) semanticObject); 
				return; 
			case CalPackage.AST_TAG:
				sequence_AstTag(context, (AstTag) semanticObject); 
				return; 
			case CalPackage.AST_TRANSITION:
				sequence_AstTransition(context, (AstTransition) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_BOOL:
				sequence_AstTypeBool(context, (AstTypeBool) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_DOUBLE:
				sequence_AstTypeDouble(context, (AstTypeDouble) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_FLOAT:
				sequence_AstTypeFloat(context, (AstTypeFloat) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_HALF:
				sequence_AstTypeHalf(context, (AstTypeHalf) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_INT:
				sequence_AstTypeInt(context, (AstTypeInt) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_LIST:
				sequence_AstTypeList(context, (AstTypeList) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_STRING:
				sequence_AstTypeString(context, (AstTypeString) semanticObject); 
				return; 
			case CalPackage.AST_TYPE_UINT:
				sequence_AstTypeUint(context, (AstTypeUint) semanticObject); 
				return; 
			case CalPackage.AST_UNIT:
				sequence_AstUnit(context, (AstUnit) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_BINARY:
				sequence_AstExpression_ExpressionAdditive_ExpressionAnd_ExpressionBitand_ExpressionBitor_ExpressionBitxor_ExpressionEq_ExpressionExp_ExpressionMultiplicative_ExpressionRelational_ExpressionShift(context, (ExpressionBinary) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_BOOLEAN:
				sequence_ExpressionBoolean(context, (ExpressionBoolean) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_CALL:
				sequence_ExpressionCall(context, (ExpressionCall) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_ELSIF:
				sequence_ExpressionElsif(context, (ExpressionElsif) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_FLOAT:
				sequence_ExpressionFloat(context, (ExpressionFloat) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_IF:
				sequence_ExpressionIf(context, (ExpressionIf) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_INDEX:
				sequence_ExpressionIndex(context, (ExpressionIndex) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_INTEGER:
				sequence_ExpressionInteger(context, (ExpressionInteger) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_LIST:
				sequence_ExpressionList(context, (ExpressionList) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_STRING:
				sequence_ExpressionString(context, (ExpressionString) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_UNARY:
				sequence_ExpressionUnary(context, (ExpressionUnary) semanticObject); 
				return; 
			case CalPackage.EXPRESSION_VARIABLE:
				sequence_ExpressionVariable(context, (ExpressionVariable) semanticObject); 
				return; 
			case CalPackage.EXTERNAL_TARGET:
				sequence_ExternalTarget(context, (ExternalTarget) semanticObject); 
				return; 
			case CalPackage.FSM:
				sequence_Fsm(context, (Fsm) semanticObject); 
				return; 
			case CalPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case CalPackage.GENERATOR:
				sequence_Generator(context, (Generator) semanticObject); 
				return; 
			case CalPackage.GUARD:
				sequence_Guard(context, (Guard) semanticObject); 
				return; 
			case CalPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case CalPackage.INEQUALITY:
				sequence_Inequality(context, (Inequality) semanticObject); 
				return; 
			case CalPackage.INPUT_PATTERN:
				sequence_InputPattern(context, (InputPattern) semanticObject); 
				return; 
			case CalPackage.LOCAL_FSM:
				sequence_LocalFsm(context, (LocalFsm) semanticObject); 
				return; 
			case CalPackage.OUTPUT_PATTERN:
				sequence_OutputPattern(context, (OutputPattern) semanticObject); 
				return; 
			case CalPackage.PRIORITY:
				sequence_Priority(context, (Priority) semanticObject); 
				return; 
			case CalPackage.REG_EXP:
				sequence_ScheduleRegExp(context, (RegExp) semanticObject); 
				return; 
			case CalPackage.REG_EXP_BINARY:
				sequence_RegExp_RegExpConcatenation(context, (RegExpBinary) semanticObject); 
				return; 
			case CalPackage.REG_EXP_TAG:
				sequence_RegExpTerminal(context, (RegExpTag) semanticObject); 
				return; 
			case CalPackage.REG_EXP_UNARY:
				sequence_RegExpPostfix(context, (RegExpUnary) semanticObject); 
				return; 
			case CalPackage.SCHEDULE_FSM:
				sequence_ScheduleFsm(context, (ScheduleFsm) semanticObject); 
				return; 
			case CalPackage.STATEMENT_ASSIGN:
				sequence_StatementAssign(context, (StatementAssign) semanticObject); 
				return; 
			case CalPackage.STATEMENT_CALL:
				sequence_StatementCall(context, (StatementCall) semanticObject); 
				return; 
			case CalPackage.STATEMENT_ELSIF:
				sequence_StatementElsif(context, (StatementElsif) semanticObject); 
				return; 
			case CalPackage.STATEMENT_FOREACH:
				sequence_StatementForeach(context, (StatementForeach) semanticObject); 
				return; 
			case CalPackage.STATEMENT_IF:
				sequence_StatementIf(context, (StatementIf) semanticObject); 
				return; 
			case CalPackage.STATEMENT_WHILE:
				sequence_StatementWhile(context, (StatementWhile) semanticObject); 
				return; 
			case CalPackage.VARIABLE:
				if (rule == grammarAccess.getActorParameterRule()) {
					sequence_ActorParameter_VariableDeclaration(context, (Variable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConstantVariableRule()) {
					sequence_ConstantVariable_VariableDeclaration(context, (Variable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTokenRule()) {
					sequence_Token(context, (Variable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStateVariableRule()
						|| rule == grammarAccess.getValuedVariableDeclarationRule()) {
					sequence_ValuedVariableDeclaration_VariableDeclaration(context, (Variable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclarationRule()) {
					sequence_VariableDeclaration(context, (Variable) semanticObject); 
					return; 
				}
				else break;
			case CalPackage.VARIABLE_REFERENCE:
				sequence_VariableReference(context, (VariableReference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActorParameter returns Variable
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* type=AstType name=ID dimensions+=AstExpression* value=AstExpression?)
	 */
	protected void sequence_ActorParameter_VariableDeclaration(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotationArgument returns AnnotationArgument
	 *
	 * Constraint:
	 *     (name=ID value=STRING?)
	 */
	protected void sequence_AnnotationArgument(ISerializationContext context, AnnotationArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstAction returns AstAction
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         tag=AstTag? 
	 *         (inputs+=InputPattern inputs+=InputPattern*)? 
	 *         (outputs+=OutputPattern outputs+=OutputPattern*)? 
	 *         guard=Guard? 
	 *         (variables+=ValuedVariableDeclaration variables+=ValuedVariableDeclaration*)? 
	 *         statements+=Statement*
	 *     )
	 */
	protected void sequence_AstAction(ISerializationContext context, AstAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstActor returns AstActor
	 *
	 * Constraint:
	 *     (
	 *         (parameters+=ActorParameter parameters+=ActorParameter*)? 
	 *         (inputs+=AstPort inputs+=AstPort*)? 
	 *         (outputs+=AstPort outputs+=AstPort*)? 
	 *         (
	 *             functions+=Function | 
	 *             procedures+=AstProcedure | 
	 *             actions+=AstAction | 
	 *             initializes+=Initialize | 
	 *             stateVariables+=StateVariable | 
	 *             localFsms+=LocalFsm
	 *         )* 
	 *         (scheduleFsm=ScheduleFsm | scheduleRegExp=ScheduleRegExp)? 
	 *         priorities+=Priority*
	 *     )
	 */
	protected void sequence_AstActor(ISerializationContext context, AstActor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstAnnotation returns AstAnnotation
	 *
	 * Constraint:
	 *     (name=ID (arguments+=AnnotationArgument arguments+=AnnotationArgument*)?)
	 */
	protected void sequence_AstAnnotation(ISerializationContext context, AstAnnotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstEntity returns AstEntity
	 *
	 * Constraint:
	 *     (package=QualifiedName? imports+=Import* annotations+=AstAnnotation* ((name=ID actor=AstActor) | (name=ID unit=AstUnit)))
	 */
	protected void sequence_AstEntity(ISerializationContext context, AstEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns ExpressionBinary
	 *     AstExpression.ExpressionBinary_1_0 returns ExpressionBinary
	 *     ExpressionAnd returns ExpressionBinary
	 *     ExpressionAnd.ExpressionBinary_1_0 returns ExpressionBinary
	 *     ExpressionBitor returns ExpressionBinary
	 *     ExpressionBitor.ExpressionBinary_1_0 returns ExpressionBinary
	 *     ExpressionBitxor returns ExpressionBinary
	 *     ExpressionBitxor.ExpressionBinary_1_0 returns ExpressionBinary
	 *     ExpressionBitand returns ExpressionBinary
	 *     ExpressionBitand.ExpressionBinary_1_0 returns ExpressionBinary
	 *     ExpressionEq returns ExpressionBinary
	 *     ExpressionEq.ExpressionBinary_1_0 returns ExpressionBinary
	 *     ExpressionRelational returns ExpressionBinary
	 *     ExpressionRelational.ExpressionBinary_1_0 returns ExpressionBinary
	 *     ExpressionShift returns ExpressionBinary
	 *     ExpressionShift.ExpressionBinary_1_0 returns ExpressionBinary
	 *     ExpressionAdditive returns ExpressionBinary
	 *     ExpressionAdditive.ExpressionBinary_1_0 returns ExpressionBinary
	 *     ExpressionMultiplicative returns ExpressionBinary
	 *     ExpressionMultiplicative.ExpressionBinary_1_0 returns ExpressionBinary
	 *     ExpressionExp returns ExpressionBinary
	 *     ExpressionExp.ExpressionBinary_1_0 returns ExpressionBinary
	 *     ExpressionUnary returns ExpressionBinary
	 *     ExpressionPostfix returns ExpressionBinary
	 *
	 * Constraint:
	 *     (
	 *         (left=AstExpression_ExpressionBinary_1_0 (operator='||' | operator='or') right=ExpressionAnd) | 
	 *         (left=ExpressionAnd_ExpressionBinary_1_0 (operator='&&' | operator='and') right=ExpressionBitor) | 
	 *         (left=ExpressionBitor_ExpressionBinary_1_0 operator='|' right=ExpressionBitxor) | 
	 *         (left=ExpressionBitxor_ExpressionBinary_1_0 operator='^' right=ExpressionBitand) | 
	 *         (left=ExpressionBitand_ExpressionBinary_1_0 operator='&' right=ExpressionEq) | 
	 *         (left=ExpressionEq_ExpressionBinary_1_0 (operator='=' | operator='!=') right=ExpressionRelational) | 
	 *         (left=ExpressionRelational_ExpressionBinary_1_0 (operator='<' | operator='<=' | operator='>' | operator='>=') right=ExpressionShift) | 
	 *         (left=ExpressionShift_ExpressionBinary_1_0 (operator='<<' | operator='>>') right=ExpressionAdditive) | 
	 *         (left=ExpressionAdditive_ExpressionBinary_1_0 (operator='+' | operator='-') right=ExpressionMultiplicative) | 
	 *         (left=ExpressionMultiplicative_ExpressionBinary_1_0 (operator='*' | operator='/' | operator='div' | operator='mod') right=ExpressionExp) | 
	 *         (left=ExpressionExp_ExpressionBinary_1_0 operator='**' right=ExpressionUnary)
	 *     )
	 */
	protected void sequence_AstExpression_ExpressionAdditive_ExpressionAnd_ExpressionBitand_ExpressionBitor_ExpressionBitxor_ExpressionEq_ExpressionExp_ExpressionMultiplicative_ExpressionRelational_ExpressionShift(ISerializationContext context, ExpressionBinary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstPort returns AstPort
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* type=AstType name=ID)
	 */
	protected void sequence_AstPort(ISerializationContext context, AstPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstProcedure returns AstProcedure
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         name=ID 
	 *         (parameters+=VariableDeclaration parameters+=VariableDeclaration*)? 
	 *         (variables+=ValuedVariableDeclaration variables+=ValuedVariableDeclaration*)? 
	 *         statements+=Statement*
	 *     )
	 */
	protected void sequence_AstProcedure(ISerializationContext context, AstProcedure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstState returns AstState
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_AstState(ISerializationContext context, AstState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_STATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_STATE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstStateAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstTag returns AstTag
	 *
	 * Constraint:
	 *     (identifiers+=ID identifiers+=ID*)
	 */
	protected void sequence_AstTag(ISerializationContext context, AstTag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstTransition returns AstTransition
	 *
	 * Constraint:
	 *     (source=[AstState|ID] tag=AstTag (target=[AstState|ID] | externalTarget=ExternalTarget))
	 */
	protected void sequence_AstTransition(ISerializationContext context, AstTransition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstType returns AstTypeBool
	 *     AstTypeBool returns AstTypeBool
	 *
	 * Constraint:
	 *     {AstTypeBool}
	 */
	protected void sequence_AstTypeBool(ISerializationContext context, AstTypeBool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstType returns AstTypeDouble
	 *     AstTypeDouble returns AstTypeDouble
	 *
	 * Constraint:
	 *     {AstTypeDouble}
	 */
	protected void sequence_AstTypeDouble(ISerializationContext context, AstTypeDouble semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstType returns AstTypeFloat
	 *     AstTypeFloat returns AstTypeFloat
	 *
	 * Constraint:
	 *     {AstTypeFloat}
	 */
	protected void sequence_AstTypeFloat(ISerializationContext context, AstTypeFloat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstType returns AstTypeHalf
	 *     AstTypeHalf returns AstTypeHalf
	 *
	 * Constraint:
	 *     {AstTypeHalf}
	 */
	protected void sequence_AstTypeHalf(ISerializationContext context, AstTypeHalf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstType returns AstTypeInt
	 *     AstTypeInt returns AstTypeInt
	 *
	 * Constraint:
	 *     size=AstExpression?
	 */
	protected void sequence_AstTypeInt(ISerializationContext context, AstTypeInt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstType returns AstTypeList
	 *     AstTypeList returns AstTypeList
	 *
	 * Constraint:
	 *     (type=AstType size=AstExpression)
	 */
	protected void sequence_AstTypeList(ISerializationContext context, AstTypeList semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_TYPE_LIST__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_TYPE_LIST__TYPE));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.AST_TYPE_LIST__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.AST_TYPE_LIST__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAstTypeListAccess().getTypeAstTypeParserRuleCall_4_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getAstTypeListAccess().getSizeAstExpressionParserRuleCall_8_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstType returns AstTypeString
	 *     AstTypeString returns AstTypeString
	 *
	 * Constraint:
	 *     {AstTypeString}
	 */
	protected void sequence_AstTypeString(ISerializationContext context, AstTypeString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstType returns AstTypeUint
	 *     AstTypeUint returns AstTypeUint
	 *
	 * Constraint:
	 *     size=AstExpression?
	 */
	protected void sequence_AstTypeUint(ISerializationContext context, AstTypeUint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstUnit returns AstUnit
	 *
	 * Constraint:
	 *     (functions+=Function | procedures+=AstProcedure | variables+=ConstantVariable)*
	 */
	protected void sequence_AstUnit(ISerializationContext context, AstUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstantVariable returns Variable
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         type=AstType 
	 *         name=ID 
	 *         dimensions+=AstExpression* 
	 *         constant?='=' 
	 *         value=AstExpression
	 *     )
	 */
	protected void sequence_ConstantVariable_VariableDeclaration(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns ExpressionBoolean
	 *     AstExpression.ExpressionBinary_1_0 returns ExpressionBoolean
	 *     ExpressionAnd returns ExpressionBoolean
	 *     ExpressionAnd.ExpressionBinary_1_0 returns ExpressionBoolean
	 *     ExpressionBitor returns ExpressionBoolean
	 *     ExpressionBitor.ExpressionBinary_1_0 returns ExpressionBoolean
	 *     ExpressionBitxor returns ExpressionBoolean
	 *     ExpressionBitxor.ExpressionBinary_1_0 returns ExpressionBoolean
	 *     ExpressionBitand returns ExpressionBoolean
	 *     ExpressionBitand.ExpressionBinary_1_0 returns ExpressionBoolean
	 *     ExpressionEq returns ExpressionBoolean
	 *     ExpressionEq.ExpressionBinary_1_0 returns ExpressionBoolean
	 *     ExpressionRelational returns ExpressionBoolean
	 *     ExpressionRelational.ExpressionBinary_1_0 returns ExpressionBoolean
	 *     ExpressionShift returns ExpressionBoolean
	 *     ExpressionShift.ExpressionBinary_1_0 returns ExpressionBoolean
	 *     ExpressionAdditive returns ExpressionBoolean
	 *     ExpressionAdditive.ExpressionBinary_1_0 returns ExpressionBoolean
	 *     ExpressionMultiplicative returns ExpressionBoolean
	 *     ExpressionMultiplicative.ExpressionBinary_1_0 returns ExpressionBoolean
	 *     ExpressionExp returns ExpressionBoolean
	 *     ExpressionExp.ExpressionBinary_1_0 returns ExpressionBoolean
	 *     ExpressionUnary returns ExpressionBoolean
	 *     ExpressionPostfix returns ExpressionBoolean
	 *     ExpressionLiteral returns ExpressionBoolean
	 *     ExpressionBoolean returns ExpressionBoolean
	 *
	 * Constraint:
	 *     value=BOOL
	 */
	protected void sequence_ExpressionBoolean(ISerializationContext context, ExpressionBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.EXPRESSION_BOOLEAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.EXPRESSION_BOOLEAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionBooleanAccess().getValueBOOLParserRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns ExpressionCall
	 *     AstExpression.ExpressionBinary_1_0 returns ExpressionCall
	 *     ExpressionAnd returns ExpressionCall
	 *     ExpressionAnd.ExpressionBinary_1_0 returns ExpressionCall
	 *     ExpressionBitor returns ExpressionCall
	 *     ExpressionBitor.ExpressionBinary_1_0 returns ExpressionCall
	 *     ExpressionBitxor returns ExpressionCall
	 *     ExpressionBitxor.ExpressionBinary_1_0 returns ExpressionCall
	 *     ExpressionBitand returns ExpressionCall
	 *     ExpressionBitand.ExpressionBinary_1_0 returns ExpressionCall
	 *     ExpressionEq returns ExpressionCall
	 *     ExpressionEq.ExpressionBinary_1_0 returns ExpressionCall
	 *     ExpressionRelational returns ExpressionCall
	 *     ExpressionRelational.ExpressionBinary_1_0 returns ExpressionCall
	 *     ExpressionShift returns ExpressionCall
	 *     ExpressionShift.ExpressionBinary_1_0 returns ExpressionCall
	 *     ExpressionAdditive returns ExpressionCall
	 *     ExpressionAdditive.ExpressionBinary_1_0 returns ExpressionCall
	 *     ExpressionMultiplicative returns ExpressionCall
	 *     ExpressionMultiplicative.ExpressionBinary_1_0 returns ExpressionCall
	 *     ExpressionExp returns ExpressionCall
	 *     ExpressionExp.ExpressionBinary_1_0 returns ExpressionCall
	 *     ExpressionUnary returns ExpressionCall
	 *     ExpressionPostfix returns ExpressionCall
	 *     ExpressionCall returns ExpressionCall
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* function=[Function|QualifiedName] (parameters+=AstExpression parameters+=AstExpression*)?)
	 */
	protected void sequence_ExpressionCall(ISerializationContext context, ExpressionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionElsif returns ExpressionElsif
	 *
	 * Constraint:
	 *     (condition=AstExpression then=AstExpression)
	 */
	protected void sequence_ExpressionElsif(ISerializationContext context, ExpressionElsif semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.EXPRESSION_ELSIF__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.EXPRESSION_ELSIF__CONDITION));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.EXPRESSION_ELSIF__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.EXPRESSION_ELSIF__THEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionElsifAccess().getConditionAstExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getExpressionElsifAccess().getThenAstExpressionParserRuleCall_3_0(), semanticObject.getThen());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns ExpressionFloat
	 *     AstExpression.ExpressionBinary_1_0 returns ExpressionFloat
	 *     ExpressionAnd returns ExpressionFloat
	 *     ExpressionAnd.ExpressionBinary_1_0 returns ExpressionFloat
	 *     ExpressionBitor returns ExpressionFloat
	 *     ExpressionBitor.ExpressionBinary_1_0 returns ExpressionFloat
	 *     ExpressionBitxor returns ExpressionFloat
	 *     ExpressionBitxor.ExpressionBinary_1_0 returns ExpressionFloat
	 *     ExpressionBitand returns ExpressionFloat
	 *     ExpressionBitand.ExpressionBinary_1_0 returns ExpressionFloat
	 *     ExpressionEq returns ExpressionFloat
	 *     ExpressionEq.ExpressionBinary_1_0 returns ExpressionFloat
	 *     ExpressionRelational returns ExpressionFloat
	 *     ExpressionRelational.ExpressionBinary_1_0 returns ExpressionFloat
	 *     ExpressionShift returns ExpressionFloat
	 *     ExpressionShift.ExpressionBinary_1_0 returns ExpressionFloat
	 *     ExpressionAdditive returns ExpressionFloat
	 *     ExpressionAdditive.ExpressionBinary_1_0 returns ExpressionFloat
	 *     ExpressionMultiplicative returns ExpressionFloat
	 *     ExpressionMultiplicative.ExpressionBinary_1_0 returns ExpressionFloat
	 *     ExpressionExp returns ExpressionFloat
	 *     ExpressionExp.ExpressionBinary_1_0 returns ExpressionFloat
	 *     ExpressionUnary returns ExpressionFloat
	 *     ExpressionPostfix returns ExpressionFloat
	 *     ExpressionLiteral returns ExpressionFloat
	 *     ExpressionFloat returns ExpressionFloat
	 *
	 * Constraint:
	 *     value=REAL
	 */
	protected void sequence_ExpressionFloat(ISerializationContext context, ExpressionFloat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.EXPRESSION_FLOAT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.EXPRESSION_FLOAT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionFloatAccess().getValueREALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns ExpressionIf
	 *     AstExpression.ExpressionBinary_1_0 returns ExpressionIf
	 *     ExpressionAnd returns ExpressionIf
	 *     ExpressionAnd.ExpressionBinary_1_0 returns ExpressionIf
	 *     ExpressionBitor returns ExpressionIf
	 *     ExpressionBitor.ExpressionBinary_1_0 returns ExpressionIf
	 *     ExpressionBitxor returns ExpressionIf
	 *     ExpressionBitxor.ExpressionBinary_1_0 returns ExpressionIf
	 *     ExpressionBitand returns ExpressionIf
	 *     ExpressionBitand.ExpressionBinary_1_0 returns ExpressionIf
	 *     ExpressionEq returns ExpressionIf
	 *     ExpressionEq.ExpressionBinary_1_0 returns ExpressionIf
	 *     ExpressionRelational returns ExpressionIf
	 *     ExpressionRelational.ExpressionBinary_1_0 returns ExpressionIf
	 *     ExpressionShift returns ExpressionIf
	 *     ExpressionShift.ExpressionBinary_1_0 returns ExpressionIf
	 *     ExpressionAdditive returns ExpressionIf
	 *     ExpressionAdditive.ExpressionBinary_1_0 returns ExpressionIf
	 *     ExpressionMultiplicative returns ExpressionIf
	 *     ExpressionMultiplicative.ExpressionBinary_1_0 returns ExpressionIf
	 *     ExpressionExp returns ExpressionIf
	 *     ExpressionExp.ExpressionBinary_1_0 returns ExpressionIf
	 *     ExpressionUnary returns ExpressionIf
	 *     ExpressionPostfix returns ExpressionIf
	 *     ExpressionIf returns ExpressionIf
	 *
	 * Constraint:
	 *     (condition=AstExpression then=AstExpression elsifs+=ExpressionElsif* else=AstExpression)
	 */
	protected void sequence_ExpressionIf(ISerializationContext context, ExpressionIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns ExpressionIndex
	 *     AstExpression.ExpressionBinary_1_0 returns ExpressionIndex
	 *     ExpressionAnd returns ExpressionIndex
	 *     ExpressionAnd.ExpressionBinary_1_0 returns ExpressionIndex
	 *     ExpressionBitor returns ExpressionIndex
	 *     ExpressionBitor.ExpressionBinary_1_0 returns ExpressionIndex
	 *     ExpressionBitxor returns ExpressionIndex
	 *     ExpressionBitxor.ExpressionBinary_1_0 returns ExpressionIndex
	 *     ExpressionBitand returns ExpressionIndex
	 *     ExpressionBitand.ExpressionBinary_1_0 returns ExpressionIndex
	 *     ExpressionEq returns ExpressionIndex
	 *     ExpressionEq.ExpressionBinary_1_0 returns ExpressionIndex
	 *     ExpressionRelational returns ExpressionIndex
	 *     ExpressionRelational.ExpressionBinary_1_0 returns ExpressionIndex
	 *     ExpressionShift returns ExpressionIndex
	 *     ExpressionShift.ExpressionBinary_1_0 returns ExpressionIndex
	 *     ExpressionAdditive returns ExpressionIndex
	 *     ExpressionAdditive.ExpressionBinary_1_0 returns ExpressionIndex
	 *     ExpressionMultiplicative returns ExpressionIndex
	 *     ExpressionMultiplicative.ExpressionBinary_1_0 returns ExpressionIndex
	 *     ExpressionExp returns ExpressionIndex
	 *     ExpressionExp.ExpressionBinary_1_0 returns ExpressionIndex
	 *     ExpressionUnary returns ExpressionIndex
	 *     ExpressionPostfix returns ExpressionIndex
	 *     ExpressionIndex returns ExpressionIndex
	 *
	 * Constraint:
	 *     (source=VariableReference indexes+=AstExpression+)
	 */
	protected void sequence_ExpressionIndex(ISerializationContext context, ExpressionIndex semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns ExpressionInteger
	 *     AstExpression.ExpressionBinary_1_0 returns ExpressionInteger
	 *     ExpressionAnd returns ExpressionInteger
	 *     ExpressionAnd.ExpressionBinary_1_0 returns ExpressionInteger
	 *     ExpressionBitor returns ExpressionInteger
	 *     ExpressionBitor.ExpressionBinary_1_0 returns ExpressionInteger
	 *     ExpressionBitxor returns ExpressionInteger
	 *     ExpressionBitxor.ExpressionBinary_1_0 returns ExpressionInteger
	 *     ExpressionBitand returns ExpressionInteger
	 *     ExpressionBitand.ExpressionBinary_1_0 returns ExpressionInteger
	 *     ExpressionEq returns ExpressionInteger
	 *     ExpressionEq.ExpressionBinary_1_0 returns ExpressionInteger
	 *     ExpressionRelational returns ExpressionInteger
	 *     ExpressionRelational.ExpressionBinary_1_0 returns ExpressionInteger
	 *     ExpressionShift returns ExpressionInteger
	 *     ExpressionShift.ExpressionBinary_1_0 returns ExpressionInteger
	 *     ExpressionAdditive returns ExpressionInteger
	 *     ExpressionAdditive.ExpressionBinary_1_0 returns ExpressionInteger
	 *     ExpressionMultiplicative returns ExpressionInteger
	 *     ExpressionMultiplicative.ExpressionBinary_1_0 returns ExpressionInteger
	 *     ExpressionExp returns ExpressionInteger
	 *     ExpressionExp.ExpressionBinary_1_0 returns ExpressionInteger
	 *     ExpressionUnary returns ExpressionInteger
	 *     ExpressionPostfix returns ExpressionInteger
	 *     ExpressionLiteral returns ExpressionInteger
	 *     ExpressionInteger returns ExpressionInteger
	 *
	 * Constraint:
	 *     (value=DECIMAL | value=OCTAL | value=HEX)
	 */
	protected void sequence_ExpressionInteger(ISerializationContext context, ExpressionInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns ExpressionList
	 *     AstExpression.ExpressionBinary_1_0 returns ExpressionList
	 *     ExpressionAnd returns ExpressionList
	 *     ExpressionAnd.ExpressionBinary_1_0 returns ExpressionList
	 *     ExpressionBitor returns ExpressionList
	 *     ExpressionBitor.ExpressionBinary_1_0 returns ExpressionList
	 *     ExpressionBitxor returns ExpressionList
	 *     ExpressionBitxor.ExpressionBinary_1_0 returns ExpressionList
	 *     ExpressionBitand returns ExpressionList
	 *     ExpressionBitand.ExpressionBinary_1_0 returns ExpressionList
	 *     ExpressionEq returns ExpressionList
	 *     ExpressionEq.ExpressionBinary_1_0 returns ExpressionList
	 *     ExpressionRelational returns ExpressionList
	 *     ExpressionRelational.ExpressionBinary_1_0 returns ExpressionList
	 *     ExpressionShift returns ExpressionList
	 *     ExpressionShift.ExpressionBinary_1_0 returns ExpressionList
	 *     ExpressionAdditive returns ExpressionList
	 *     ExpressionAdditive.ExpressionBinary_1_0 returns ExpressionList
	 *     ExpressionMultiplicative returns ExpressionList
	 *     ExpressionMultiplicative.ExpressionBinary_1_0 returns ExpressionList
	 *     ExpressionExp returns ExpressionList
	 *     ExpressionExp.ExpressionBinary_1_0 returns ExpressionList
	 *     ExpressionUnary returns ExpressionList
	 *     ExpressionPostfix returns ExpressionList
	 *     ExpressionList returns ExpressionList
	 *
	 * Constraint:
	 *     (expressions+=AstExpression expressions+=AstExpression* (generators+=Generator generators+=Generator*)?)
	 */
	protected void sequence_ExpressionList(ISerializationContext context, ExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns ExpressionString
	 *     AstExpression.ExpressionBinary_1_0 returns ExpressionString
	 *     ExpressionAnd returns ExpressionString
	 *     ExpressionAnd.ExpressionBinary_1_0 returns ExpressionString
	 *     ExpressionBitor returns ExpressionString
	 *     ExpressionBitor.ExpressionBinary_1_0 returns ExpressionString
	 *     ExpressionBitxor returns ExpressionString
	 *     ExpressionBitxor.ExpressionBinary_1_0 returns ExpressionString
	 *     ExpressionBitand returns ExpressionString
	 *     ExpressionBitand.ExpressionBinary_1_0 returns ExpressionString
	 *     ExpressionEq returns ExpressionString
	 *     ExpressionEq.ExpressionBinary_1_0 returns ExpressionString
	 *     ExpressionRelational returns ExpressionString
	 *     ExpressionRelational.ExpressionBinary_1_0 returns ExpressionString
	 *     ExpressionShift returns ExpressionString
	 *     ExpressionShift.ExpressionBinary_1_0 returns ExpressionString
	 *     ExpressionAdditive returns ExpressionString
	 *     ExpressionAdditive.ExpressionBinary_1_0 returns ExpressionString
	 *     ExpressionMultiplicative returns ExpressionString
	 *     ExpressionMultiplicative.ExpressionBinary_1_0 returns ExpressionString
	 *     ExpressionExp returns ExpressionString
	 *     ExpressionExp.ExpressionBinary_1_0 returns ExpressionString
	 *     ExpressionUnary returns ExpressionString
	 *     ExpressionPostfix returns ExpressionString
	 *     ExpressionLiteral returns ExpressionString
	 *     ExpressionString returns ExpressionString
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_ExpressionString(ISerializationContext context, ExpressionString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.EXPRESSION_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.EXPRESSION_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStringAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns ExpressionUnary
	 *     AstExpression.ExpressionBinary_1_0 returns ExpressionUnary
	 *     ExpressionAnd returns ExpressionUnary
	 *     ExpressionAnd.ExpressionBinary_1_0 returns ExpressionUnary
	 *     ExpressionBitor returns ExpressionUnary
	 *     ExpressionBitor.ExpressionBinary_1_0 returns ExpressionUnary
	 *     ExpressionBitxor returns ExpressionUnary
	 *     ExpressionBitxor.ExpressionBinary_1_0 returns ExpressionUnary
	 *     ExpressionBitand returns ExpressionUnary
	 *     ExpressionBitand.ExpressionBinary_1_0 returns ExpressionUnary
	 *     ExpressionEq returns ExpressionUnary
	 *     ExpressionEq.ExpressionBinary_1_0 returns ExpressionUnary
	 *     ExpressionRelational returns ExpressionUnary
	 *     ExpressionRelational.ExpressionBinary_1_0 returns ExpressionUnary
	 *     ExpressionShift returns ExpressionUnary
	 *     ExpressionShift.ExpressionBinary_1_0 returns ExpressionUnary
	 *     ExpressionAdditive returns ExpressionUnary
	 *     ExpressionAdditive.ExpressionBinary_1_0 returns ExpressionUnary
	 *     ExpressionMultiplicative returns ExpressionUnary
	 *     ExpressionMultiplicative.ExpressionBinary_1_0 returns ExpressionUnary
	 *     ExpressionExp returns ExpressionUnary
	 *     ExpressionExp.ExpressionBinary_1_0 returns ExpressionUnary
	 *     ExpressionUnary returns ExpressionUnary
	 *     ExpressionPostfix returns ExpressionUnary
	 *
	 * Constraint:
	 *     ((unaryOperator='~' | unaryOperator='not' | unaryOperator='-' | unaryOperator='#') expression=ExpressionPostfix)
	 */
	protected void sequence_ExpressionUnary(ISerializationContext context, ExpressionUnary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AstExpression returns ExpressionVariable
	 *     AstExpression.ExpressionBinary_1_0 returns ExpressionVariable
	 *     ExpressionAnd returns ExpressionVariable
	 *     ExpressionAnd.ExpressionBinary_1_0 returns ExpressionVariable
	 *     ExpressionBitor returns ExpressionVariable
	 *     ExpressionBitor.ExpressionBinary_1_0 returns ExpressionVariable
	 *     ExpressionBitxor returns ExpressionVariable
	 *     ExpressionBitxor.ExpressionBinary_1_0 returns ExpressionVariable
	 *     ExpressionBitand returns ExpressionVariable
	 *     ExpressionBitand.ExpressionBinary_1_0 returns ExpressionVariable
	 *     ExpressionEq returns ExpressionVariable
	 *     ExpressionEq.ExpressionBinary_1_0 returns ExpressionVariable
	 *     ExpressionRelational returns ExpressionVariable
	 *     ExpressionRelational.ExpressionBinary_1_0 returns ExpressionVariable
	 *     ExpressionShift returns ExpressionVariable
	 *     ExpressionShift.ExpressionBinary_1_0 returns ExpressionVariable
	 *     ExpressionAdditive returns ExpressionVariable
	 *     ExpressionAdditive.ExpressionBinary_1_0 returns ExpressionVariable
	 *     ExpressionMultiplicative returns ExpressionVariable
	 *     ExpressionMultiplicative.ExpressionBinary_1_0 returns ExpressionVariable
	 *     ExpressionExp returns ExpressionVariable
	 *     ExpressionExp.ExpressionBinary_1_0 returns ExpressionVariable
	 *     ExpressionUnary returns ExpressionVariable
	 *     ExpressionPostfix returns ExpressionVariable
	 *     ExpressionVariable returns ExpressionVariable
	 *
	 * Constraint:
	 *     value=VariableReference
	 */
	protected void sequence_ExpressionVariable(ISerializationContext context, ExpressionVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.EXPRESSION_VARIABLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.EXPRESSION_VARIABLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionVariableAccess().getValueVariableReferenceParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExternalTarget returns ExternalTarget
	 *
	 * Constraint:
	 *     (fsm=[LocalFsm|ID] state=[AstState|ID] from=[AstState|ID] to=[AstState|ID])
	 */
	protected void sequence_ExternalTarget(ISerializationContext context, ExternalTarget semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.EXTERNAL_TARGET__FSM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.EXTERNAL_TARGET__FSM));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.EXTERNAL_TARGET__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.EXTERNAL_TARGET__STATE));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.EXTERNAL_TARGET__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.EXTERNAL_TARGET__FROM));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.EXTERNAL_TARGET__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.EXTERNAL_TARGET__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalTargetAccess().getFsmLocalFsmIDTerminalRuleCall_0_0_1(), semanticObject.getFsm());
		feeder.accept(grammarAccess.getExternalTargetAccess().getStateAstStateIDTerminalRuleCall_2_0_1(), semanticObject.getState());
		feeder.accept(grammarAccess.getExternalTargetAccess().getFromAstStateIDTerminalRuleCall_4_0_1(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getExternalTargetAccess().getToAstStateIDTerminalRuleCall_6_0_1(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fsm returns Fsm
	 *
	 * Constraint:
	 *     transitions+=AstTransition*
	 */
	protected void sequence_Fsm(ISerializationContext context, Fsm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         name=ID 
	 *         (parameters+=VariableDeclaration parameters+=VariableDeclaration*)? 
	 *         type=AstType 
	 *         ((variables+=ValuedVariableDeclaration variables+=ValuedVariableDeclaration*)? expression=AstExpression)?
	 *     )
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Generator returns Generator
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration lower=AstExpression higher=AstExpression)
	 */
	protected void sequence_Generator(ISerializationContext context, Generator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.GENERATOR__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.GENERATOR__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.GENERATOR__LOWER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.GENERATOR__LOWER));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.GENERATOR__HIGHER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.GENERATOR__HIGHER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneratorAccess().getVariableVariableDeclarationParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getGeneratorAccess().getLowerAstExpressionParserRuleCall_3_0(), semanticObject.getLower());
		feeder.accept(grammarAccess.getGeneratorAccess().getHigherAstExpressionParserRuleCall_5_0(), semanticObject.getHigher());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Guard returns Guard
	 *
	 * Constraint:
	 *     (expressions+=AstExpression expressions+=AstExpression*)
	 */
	protected void sequence_Guard(ISerializationContext context, Guard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildCard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildCardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Inequality returns Inequality
	 *
	 * Constraint:
	 *     (tags+=AstTag tags+=AstTag+)
	 */
	protected void sequence_Inequality(ISerializationContext context, Inequality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initialize returns AstAction
	 *
	 * Constraint:
	 *     (
	 *         annotations+=AstAnnotation* 
	 *         tag=AstTag? 
	 *         (outputs+=OutputPattern outputs+=OutputPattern*)? 
	 *         guard=Guard? 
	 *         (variables+=ValuedVariableDeclaration variables+=ValuedVariableDeclaration*)? 
	 *         statements+=Statement*
	 *     )
	 */
	protected void sequence_Initialize(ISerializationContext context, AstAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputPattern returns InputPattern
	 *
	 * Constraint:
	 *     (port=[AstPort|ID] tokens+=Token tokens+=Token* repeat=AstExpression?)
	 */
	protected void sequence_InputPattern(ISerializationContext context, InputPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocalFsm returns LocalFsm
	 *
	 * Constraint:
	 *     (name=ID contents=Fsm)
	 */
	protected void sequence_LocalFsm(ISerializationContext context, LocalFsm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.LOCAL_FSM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.LOCAL_FSM__NAME));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.LOCAL_FSM__CONTENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.LOCAL_FSM__CONTENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalFsmAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocalFsmAccess().getContentsFsmParserRuleCall_4_0(), semanticObject.getContents());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputPattern returns OutputPattern
	 *
	 * Constraint:
	 *     (port=[AstPort|ID] values+=AstExpression values+=AstExpression* repeat=AstExpression?)
	 */
	protected void sequence_OutputPattern(ISerializationContext context, OutputPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Priority returns Priority
	 *
	 * Constraint:
	 *     inequalities+=Inequality*
	 */
	protected void sequence_Priority(ISerializationContext context, Priority semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns RegExpUnary
	 *     RegExp.RegExpBinary_1_0 returns RegExpUnary
	 *     RegExpConcatenation returns RegExpUnary
	 *     RegExpConcatenation.RegExpBinary_1_0 returns RegExpUnary
	 *     RegExpPostfix returns RegExpUnary
	 *     RegExpPostfix.RegExpUnary_1_0 returns RegExpUnary
	 *     RegExpGrouping returns RegExpUnary
	 *
	 * Constraint:
	 *     (child=RegExpPostfix_RegExpUnary_1_0 (unaryOperator='*' | unaryOperator='?'))
	 */
	protected void sequence_RegExpPostfix(ISerializationContext context, RegExpUnary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns RegExpTag
	 *     RegExp.RegExpBinary_1_0 returns RegExpTag
	 *     RegExpConcatenation returns RegExpTag
	 *     RegExpConcatenation.RegExpBinary_1_0 returns RegExpTag
	 *     RegExpPostfix returns RegExpTag
	 *     RegExpPostfix.RegExpUnary_1_0 returns RegExpTag
	 *     RegExpGrouping returns RegExpTag
	 *     RegExpTerminal returns RegExpTag
	 *
	 * Constraint:
	 *     tag=AstTag
	 */
	protected void sequence_RegExpTerminal(ISerializationContext context, RegExpTag semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.REG_EXP_TAG__TAG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.REG_EXP_TAG__TAG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegExpTerminalAccess().getTagAstTagParserRuleCall_1_0(), semanticObject.getTag());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns RegExpBinary
	 *     RegExp.RegExpBinary_1_0 returns RegExpBinary
	 *     RegExpConcatenation returns RegExpBinary
	 *     RegExpConcatenation.RegExpBinary_1_0 returns RegExpBinary
	 *     RegExpPostfix returns RegExpBinary
	 *     RegExpPostfix.RegExpUnary_1_0 returns RegExpBinary
	 *     RegExpGrouping returns RegExpBinary
	 *
	 * Constraint:
	 *     ((left=RegExp_RegExpBinary_1_0 operator='|' right=RegExpConcatenation) | (left=RegExpConcatenation_RegExpBinary_1_0 right=RegExpPostfix))
	 */
	protected void sequence_RegExp_RegExpConcatenation(ISerializationContext context, RegExpBinary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScheduleFsm returns ScheduleFsm
	 *
	 * Constraint:
	 *     (initialState=[AstState|ID] contents=Fsm)
	 */
	protected void sequence_ScheduleFsm(ISerializationContext context, ScheduleFsm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.SCHEDULE_FSM__INITIAL_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.SCHEDULE_FSM__INITIAL_STATE));
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.SCHEDULE_FSM__CONTENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.SCHEDULE_FSM__CONTENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScheduleFsmAccess().getInitialStateAstStateIDTerminalRuleCall_2_0_1(), semanticObject.getInitialState());
		feeder.accept(grammarAccess.getScheduleFsmAccess().getContentsFsmParserRuleCall_4_0(), semanticObject.getContents());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScheduleRegExp returns RegExp
	 *
	 * Constraint:
	 *     exp=RegExp
	 */
	protected void sequence_ScheduleRegExp(ISerializationContext context, RegExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.REG_EXP__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.REG_EXP__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScheduleRegExpAccess().getExpRegExpParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StatementAssign returns StatementAssign
	 *     Statement returns StatementAssign
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* target=VariableReference indexes+=AstExpression* value=AstExpression)
	 */
	protected void sequence_StatementAssign(ISerializationContext context, StatementAssign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementCall returns StatementCall
	 *     Statement returns StatementCall
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* procedure=[AstProcedure|QualifiedName] (arguments+=AstExpression arguments+=AstExpression*)?)
	 */
	protected void sequence_StatementCall(ISerializationContext context, StatementCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementElsif returns StatementElsif
	 *
	 * Constraint:
	 *     (condition=AstExpression then+=Statement*)
	 */
	protected void sequence_StatementElsif(ISerializationContext context, StatementElsif semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementForeach returns StatementForeach
	 *     Statement returns StatementForeach
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* variable=VariableDeclaration lower=AstExpression higher=AstExpression statements+=Statement*)
	 */
	protected void sequence_StatementForeach(ISerializationContext context, StatementForeach semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementIf returns StatementIf
	 *     Statement returns StatementIf
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* condition=AstExpression then+=Statement* elsifs+=StatementElsif* else+=Statement*)
	 */
	protected void sequence_StatementIf(ISerializationContext context, StatementIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementWhile returns StatementWhile
	 *     Statement returns StatementWhile
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* condition=AstExpression statements+=Statement*)
	 */
	protected void sequence_StatementWhile(ISerializationContext context, StatementWhile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Token returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Token(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTokenAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateVariable returns Variable
	 *     ValuedVariableDeclaration returns Variable
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* type=AstType name=ID dimensions+=AstExpression* (constant?='='? value=AstExpression)?)
	 */
	protected void sequence_ValuedVariableDeclaration_VariableDeclaration(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns Variable
	 *
	 * Constraint:
	 *     (annotations+=AstAnnotation* type=AstType name=ID dimensions+=AstExpression*)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableReference returns VariableReference
	 *
	 * Constraint:
	 *     variable=[Variable|QualifiedName]
	 */
	protected void sequence_VariableReference(ISerializationContext context, VariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CalPackage.Literals.VARIABLE_REFERENCE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CalPackage.Literals.VARIABLE_REFERENCE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableReferenceAccess().getVariableVariableQualifiedNameParserRuleCall_0_1(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
}
